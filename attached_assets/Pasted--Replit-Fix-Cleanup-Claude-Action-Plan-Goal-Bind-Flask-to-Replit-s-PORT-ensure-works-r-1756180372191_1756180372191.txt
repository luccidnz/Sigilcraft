üõ†Ô∏è Replit Fix & Cleanup ‚Äî Claude Action Plan

Goal: Bind Flask to Replit‚Äôs $PORT, ensure / works, remove legacy/blocking files & hard-coded hosts/ports, fix frontend calls, and retest until zero errors.

0) Prep (branch + snapshot)

Create branch: fix/replit-port-cleanup.

Create a Replit snapshot/export.

1) Identify real entrypoint

Open .replit. If missing or incorrect, set:

run = "python3 main.py"


If the true entry file isn‚Äôt main.py, replace with that filename (e.g., app.py).

Confirm which file creates the Flask app object (app = Flask(...)). We‚Äôll call this file ENTRY.

2) Patch ENTRY to use Replit‚Äôs $PORT and add health route

Ensure these imports & app exist near the top of ENTRY:

import os
from flask import Flask
try:
    app
except NameError:
    app = Flask(__name__)


Ensure a root route exists (create if missing):

@app.get("/")
def health():
    app.logger.info("‚úÖ Root health check accessed")
    return "OK", 200


Replace the runner at the bottom of ENTRY:

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 5000))
    print(f"üîå Using PORT={port}")
    app.run(host="0.0.0.0", port=port, debug=False)

3) Global search & replace: kill hard-coded ports/hosts

Search the whole repo for each of these and fix every hit:

:5001 ‚Üí remove or route through $PORT (server), or use relative paths in frontend.

:5000

http://127.0.0.1

http://localhost

app.run( with a literal port=...

For server code, only the ENTRY file may call app.run(...) with $PORT as above.

For frontend code (JS/TS/HTML):

Replace absolute URLs like http://localhost:5001/api/... with relative paths: "/api/...".

4) Remove/neutralize legacy & conflicting files

If any of these exist and aren‚Äôt actively used, move them to __archive__/ (don‚Äôt hard delete):

Extra server files (server.py, run.py, wsgi.py, duplicate app.py/main.py).

Old deploy configs: Procfile, vercel.json, railway.json, render.yaml, stray Dockerfile.

Old static builds you‚Äôre not serving (build/, dist/) ‚Äî if unused, archive entire folders.

Ensure there is only one Flask entry file launching the server (the ENTRY file above).

5) (If frontend is separate) enable CORS

If a separate frontend hits the API (different origin):

try:
    from flask_cors import CORS
    CORS(app)
except Exception as e:
    print("CORS not enabled:", e)


Also ensure flask-cors is in requirements.txt.

6) Dependencies tidy

Make sure requirements.txt contains at least what you import (examples):

Flask
gunicorn
flask-cors
Pillow
numpy


Install/upgrade:

pip install --upgrade pip
pip install -r requirements.txt

7) Quick smoke tests (create if missing)

Add tests/test_smoke.py:

import pytest
from ENTRY_BASENAME import app  # e.g., from main import app

@pytest.fixture
def client():
    app.testing = True
    with app.test_client() as c:
        yield c

def test_root_ok(client):
    r = client.get("/")
    assert r.status_code in (200, 204)

# Adjust to a real API path if present:
def test_api_exists_shape(client):
    r = client.get("/api/sigil")
    assert r.status_code in (200, 400, 401, 404, 422)


Replace ENTRY_BASENAME with the filename (without .py) that defines app.

8) Run & verify (loop until clean)

Stop the repl, then Run.

Confirm logs show üîå Using PORT=<some number> (not 5001/5000).

Open webview:

/ should return OK.

Manually hit key routes: /api/... and confirm non-500 responses.

Run tests:

pytest -q


If any failures:

404 ‚Üí route missing/typo: fix route name or frontend path.

CORS ‚Üí ensure flask-cors added and CORS(app) executed.

500 ‚Üí read stacktrace, fix line(s), re-run.

Repeat steps 1‚Äì5 until: no 500s in logs, / is 200, and tests pass.

9) Deploy settings (optional)

If using Replit Deploy, set the start command to:

gunicorn -b 0.0.0.0:$PORT ENTRY_BASENAME:app


(Replace ENTRY_BASENAME accordingly.)

10) Commit & merge
git add -A
git commit -m "Bind Flask to $PORT, add health route, remove legacy files, fix frontend URLs, add smoke tests"
git merge --no-ff fix/replit-port-cleanup

Acceptance Criteria

Logs show üîå Using PORT=<assigned> (not 5001/5000).

/ responds 200 OK.

All core API routes reachable from the webview (no hard-coded localhost/ports).

pytest smoke tests pass.

No duplicate servers/configs left in root.

No absolute localhost/:5001 remains in repo.

I